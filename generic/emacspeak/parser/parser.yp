#
# Copyright (C) 2017 Mike Ray <mike.ray@btinternet.com>
#
# Parse::Yapp grammar/parser/lexer for the Emacspeak text-to-speech protocol.
#
# This is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this package; see the file COPYING.  If not, write to
# the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
# Boston, MA 02110-1301, USA.
#
#--code--


# This is work in progress, not working yet


%%

# Rules section

cmdlist
	: 
	| cmdlist cmd
	;

cmd
	: code { $_[1]; }
	| speech { $_[1]; }
	| dispatch { $_[1]; &tts_d(); }
	| stop { $_[1]; &tts_s(); }
	| version { $_[1]; &tts_version(); }
	| silence { $_[1]; &tts_silence($1); }
	| beep { $_[1]; }
	| tone { $_[1]; }
	| sound { $_[1]; }
	| tts_pause { $_[1]; &tts_pause(); }
	| tts_reset { $_[1]; &tts_reset(); }
	| tts_resume { $_[1]; &tts_reset(); }
	| tts_allcaps_beep { $_[1]; &tts_allcaps_beep($1); }
	| tts_capitalize { $_[1]; &tts_capitalize($1)}
	| tts_set_character_scale { $_[1]; }
	| tts_set_punctuations { $_[1]; &tts_set_punctuations($_[1]); }
	| tts_set_speech_rate { $_[1]; &tts_set_speech_rate($_[1]); }
	| tts_split_caps { $_[1]; &tts_split_caps($_[1]); }
	| tts_sync_state { $_[1]; }
	;

code
	: 'C' '{' TEXT '}' '\n'
		{
			$_[1];
			&tts_c($_[3]);
		}
	| 'C' TEXT '\n'
		{
			$_[1];
			&tts_c($_[2]);
		}
	;

speech
	: immediate_speech { $_[1]; }
	| queued_speech { $_[1]; }
	| character { $_[1]; }
	;

immediate_speech
	: 'TTS_SAY' '{' TEXT '}' '\n'
		{
			$_[1];
			&tts_say($_[3]);
		}
	| 'TTS_SAY' TEXT '\n'
		{
			$_[1];
			&tts_say($_[2]);
		}
	;

character
	: 'L' '{' CHAR '}' '\n'
		{
			$_[1];
			&tts_l($_[3]);
		}
	| 'L' CHAR '\n'
		{
			$_[1];
			&tts_l($_[2]);
		}
	;

queued_speech
	: 'Q' '{' TEXT '}' '\n'
		{
			$_[1];
			&tts_q($_[3]);
		}
	| 'Q' TEXT '\n'
		{
			$_[1];
			&tts_q($_[2]);
		}
	;

dispatch
	: 'D' '\n' { $_[1]; }
	;

version
	: 'VERSION' '\n' { $_[1]; }
	;

stop
	: 'S' '\n' { $_[1]; }
	;

silence
	: 'SH' '{' INTEGER '}' '\n' { $_[3]; }
	| 'SH' INTEGER '\n' { $_[2]; }
	;

beep
	: 'B' '{' INTEGER INTEGER '}' '\n'
		{
			$_[1];
			&tts_b($_[3], $4);
		}
	| 'B' INTEGER INTEGER '\n'
		{
			$_[1];
			&tts_b($_[2], $_[3]);
		}
	;

tone
	: 'T' '{' INTEGER INTEGER '}' '\n'
		{
			$_[1];
			&ts_t($_[3], $4);
		}
	| 'T' INTEGER INTEGER '\n'
		{
			$_[1];
			&tts_t($_[2], $_[3]);
		}
	;

sound
	: 'A' '{' TEXT '}' '\n'
		{
			$_[1];
			&tts_a($_[3]);
		}
	| 'A' TEXT '\n'
		{
			$_[1];
			&tts_a($_[2]);
		}
	;

tts_pause
	: 'TTS_PAUSE' '\n' { $_[1]; }
	;

tts_reset
	: 'TTS_RESET' '\n' { $_[1]; }
	;

tts_resume
	: 'TTS_RESUME' '\n' { $_[1]; }
	;

tts_allcaps_beep
	: 'TTS_ALLCAPS_BEEP' '{' FLAG '}' '\n' { $_[3]; }
	| 'TTS_ALLCAPS_BEEP' FLAG '\n' { $_[2]; }
	;

tts_capitalize
	: 'TTS_CAPITALIZE' '{' FLAG '}' '\n' { $_[3]; }
	| 'TTS_CAPITALIZE' FLAG '\n' { $_[2]; }
	;

tts_set_character_scale
	: 'TTS_SET_CHARACTER_SCALE' '{' DOUBLE '}' '\n'
		{
			$_[1];
			&tts_set_character_scale($_[3]);
		}
	| 'TTS_SET_CHARACTER_SCALE' DOUBLE '\n'
		{
			$_[1];
			&tts_set_character_scale($_[2]);
		}
	;

tts_set_punctuations
	: 'TTS_SET_PUNCTUATIONS' '{' punctlevel '}' '\n' { $_[3]; }
	| 'TTS_SET_PUNCTUATIONS' punctlevel '\n' { $_[2]; }
	;

tts_set_speech_rate
	: 'TTS_SET_SPEECH_RATE' '{' INTEGER '}' '\n' { $_[3]; }
	| 'TTS_SET_SPEECH_RATE' INTEGER '\n' { $_[2]; }
	;

tts_split_caps
	: 'TTS_SPLIT_CAPS' '{' FLAG '}' '\n' { $_[3]; }
	| 'TTS_SPLIT_CAPS' FLAG '\n' { $_[2]; }
	;

tts_sync_state
	: 'TTS_SYNC_STATE' '{' punctlevel FLAG FLAG FLAG INTEGER '}' '\n'
		{ 
			$_[1];
			&tts_sync_state($_[3], $4, $5, $6, $7);
		}
	| 'TTS_SYNC_STATE' punctlevel FLAG FLAG FLAG INTEGER '\n'
		{
			$_[1];
			&tts_sync_state($_[2],$_[3], $4, $5, $6);
		}
	;

punctlevel
	: 'PUNCT_NONE'
	| 'PUNCT_SOME'
	| 'PUNCT_ALL'
	;

%%

# Bottom section

sub _Error {
	exists $_[0]->YYData->{ERRMSG}
		and do {
			print $_[0]->YYData->{ERRMSG};
			delete $_[0]->YYData->{ERRMSG};
			return;
	};
    
	print "Syntax error.\n";

} # sub _Error

sub _Lexer {
	my($parser)=shift;

	$parser->YYData->{INPUT}
		or  $parser->YYData->{INPUT} = <STDIN>
		or  return('',undef);

	#$parser->YYData->{INPUT} =~ s/^[ \t]//;

	for ($parser->YYData->{INPUT}) {
		# tts_say, immediate speech
		s/^(tts_say)// and return('TTS_SAY',$1);

		# Version, no arguments
		s/^(version)// and return('VERSION',$1);

		# punctuation levels
		s/^((none|some|all))// and return('PUNCTLEVEL',$1);

		# Pause, reset and resume have no arguments

		# pause
		s/^(tts_pause)// and return('TTS_PAUSE',$1);

		# reset 
		s/^(tts_reset)// and return('TTS_RESET',$1);

		# resume 
		s/^(tts_resume)// and return('TTS_RESUME',$1);

		# These tts_* functions either have braces or not

		# tts_allcaps_beep
		s/^(tts_allcaps_beep)// and return('TTS_ALLCAPS_BEEP',$1);

		# tts_capitalize
		s/^(tts_capitalize)// and return('TTS_CAPITALIZE',$1);

		# tts_set_character_scale
		s/^(tts_set_character_scale)// and return('TTS_SET_CHARACTER_SCALE',$1);

		# tts_set_punctuations	
		s/^(tts_set_punctuations)// and return('TTS_SET_PUNCTUATIONS',$1);

		# tts_set_speech_rate
		s/^(tts_set_speech_rate)// and return('TTS_SET_SPEECH_RATE',$1);

		# tts_split_caps
		s/^(tts_split_caps)// and return('TTS_SPLIT_CAPS',$1);

		# tts_sync_state with or without braces but I've never seen braces

		# tts_sync_state
		s/^(tts_sync_state)// and return('TTS_SYNC_STATE',$1);

	# silence 'sh'
		s/^(sh)// and return('SH',$1);

		# Start of single-character patterns

		# code 'c'
		s/^(c)// and return(uc($1),$1);

		# single letter 'l'
		s/^(l)// and return(uc($1),$1);

		# queued speech 'q'
		s/^(q)// and return(uc($1),$1);

		# tone 't' 
		s/^(t)// and return(uc($1),$1);

		# beep 'b'
		s/^(b)// and return(uc($1),$1);

		# sound file 'a' or 'p'
		s/^((a|p))// and return(uc($1),$1);

		# numeric patterns

		# integer
		s/^([0-9][0-9]+)// and return('INTEGER',$1);

		# double
		s/^([-+]?([0-9]*\.?[0-9]+|[0-9]+\.))// and return('DOUBLE',$1);

		# flag 0 or 1
		s/^([01])// and return('FLAG',$1);

		# Left-brace
		s/^({)// and return($1,$1);

		# Right-brace
		s/^(})// and return($1,$1);

		# newline
		s/^(\n)// and return($1,$1);

		# Eat white space
		s/^\s+//;

	}

} # end of _Lexer

sub Run {
	my($self)=shift;
	$self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
} # end of Run

my $p = new MyParser;
$p->Run;




